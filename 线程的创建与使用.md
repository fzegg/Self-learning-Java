# 线程的创建与使用

### 多线程的创建

- 方式一：继承于Thread类

  - 创建一个继承于Thread类的子类
  - 重写Thread类的子类对象—>将此线程执行的操作声明在run()中
  - 创建此Thread子类的对象
  - 通过此对象调用start()

  ```java
  //创建子类
  class MyThread extends Thread{
      //重写run()
      @Override
      public void run(){
          for(int i = 0; i < 100; i++){
  			if(i % 2 == 0){
  				System.out.println(i);
  			}
      	}
      }
  }
  public class ThreadTest {
  	public static void main(String[] args) {
  	//创建Thread 类的于类的对象
  		MyThread t1 = new MyThread();
  	//通过此对象调用start()
  		t1.start();
      	    
      	for(int i = 0; i < 100; i++){
  			if(i % 2 != 0){
  				System.out.println(i + "***");
  			}
      	}    
      }
  }
  ```

### Thread类中的常用方法

- start(): 启动当前线程:调用当前线程的run()
- run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中
- currentThread(): 静态方法，返回执行当前代码的线程
- getName(): 获取当前线程的名字
- setName(): 设置当前线程的名字
- yield(): 释放当前cpu的执行权
- join(): 在线程A中调用线程B的join()方法，此时线程A就进入阻塞状态，直到线程B执行结束，线程A结束阻塞状态
- stop(): 已过时。执行此方法时
- sleep(long millitime): 让当前线程阻塞指定的毫秒，在指定的时间内当前线程是阻塞状态。
- isAlive(): 判断当前线程是否存活

### 线程的调度

- 线程优先级：

  MAX_PRIORITY: 10

  MIN_PRIORITY: 1

  NORM_PRIORITY: 5->默认优先级

- 如何获取和设置当前的线程优先级

  getPriority():获取线程的优先级

  setPriority(int p):设置线程的优先级

说明：高优先级的线程要抢占低优先级线程cpu的执行权。但只是从概率上讲，高优先级的线程高概率的情况下被执行，并不意味着高优先级的线程被执行后低优先级的线程才执行

```java
class HelloThread extends Thread{
	@Override
	public void run() {
		for(int i=0;i < 100; i++){
			if(i % 2 == 0){
               /* try{
                    sleep(1000);
                } catch (InterruptedException e){
					e.printstackTrace();
            	}*/
				System.out.println(getName() + ":" + getPriority() + i);
            }
            if(i % 20 == 0){
				this.yield();
            }
        }
    }
}

public HelloThread(String name){
	super(name); 
}
public class ThreadMethodTest {
	public static void main(String[] args) {
		HelloThread h1 = new HelloThread("Thread1");
        
		h1.setName("线程一");
        
        //设置分线程的优先级
        h1.setPriority(Thread.MAX_PRIORITY);
        
		h1.start();
		//给主线程命名
		Thread.currentThread().setName("主线程");
		Thread.currentThread(Thread.MIN_PRIORITY);
        
        for(inti=0;i<100;i++){
			if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ":" + Thread.currentThread().getPriority() + i);
            }
            if(i == 20){
                try{
                	h1.join();
                } catch (InterruptedException e){
                	e.printstackTrace();    
                }
            }
        }
        System.out.println(h1.isAlive());
    }
}
```

### 

